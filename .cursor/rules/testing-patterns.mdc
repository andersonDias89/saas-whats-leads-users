# Padrões de Teste - Cursor SaaS WhatsApp Leads

## 🧪 Estrutura de Testes

### **Localização dos Testes:**
- Testes em `__tests__/` seguindo a estrutura do `src/`
- Testes de schemas: `__tests__/schemas/[domain]/`
- Testes de hooks: `__tests__/hooks/[domain]/`
- Testes de componentes: `__tests__/components/[type]/`
- Testes de serviços: `__tests__/services/[domain]/`
- Testes de APIs: `__tests__/api/[domain]/`
- Testes de integração: `__tests__/integration/`

### **Configuração:**
- Jest configurado em [jest.config.js](mdc:jest.config.js)
- Setup global em [jest.setup.js](mdc:jest.setup.js)
- Mocks configurados para Next.js, Prisma, fetch, toast, socket.io

## 📝 Padrões de Nomenclatura

### **Arquivos de Teste:**
```typescript
// Nome do arquivo: feature.test.ts ou feature.test.tsx
describe('Feature', () => {
  describe('Método ou Funcionalidade', () => {
    test('deve fazer algo específico', () => {
      // teste
    })
  })
})
```

### **Testes de Schema (Zod):**
```typescript
describe('LeadSchema', () => {
  test('deve validar dados válidos', () => {
    const validData = { /* dados válidos */ }
    const result = leadSchema.safeParse(validData)
    expect(result.success).toBe(true)
  })

  test('deve rejeitar dados inválidos', () => {
    const invalidData = { /* dados inválidos */ }
    const result = leadSchema.safeParse(invalidData)
    expect(result.success).toBe(false)
  })
})
```

### **Testes de Hooks:**
```typescript
describe('useLeads', () => {
  beforeEach(() => {
    jest.clearAllMocks()
    jest.spyOn(console, 'error').mockImplementation(() => {})
  })

  afterEach(() => {
    jest.restoreAllMocks()
  })

  test('deve carregar leads com sucesso', async () => {
    // mock fetch
    global.fetch = jest.fn(() =>
      Promise.resolve({
        ok: true,
        json: () => Promise.resolve([/* leads */])
      })
    )

    // render hook
    const { result } = renderHook(() => useLeads())
    
    // aguardar carregamento
    await waitFor(() => {
      expect(result.current.isLoading).toBe(false)
    })
  })
})
```

### **Testes de Componentes:**
```typescript
describe('Button', () => {
  test('deve renderizar corretamente', () => {
    render(<Button>Click me</Button>)
    expect(screen.getByRole('button')).toBeInTheDocument()
  })

  test('deve chamar onClick quando clicado', () => {
    const handleClick = jest.fn()
    render(<Button onClick={handleClick}>Click me</Button>)
    
    fireEvent.click(screen.getByRole('button'))
    expect(handleClick).toHaveBeenCalledTimes(1)
  })
})
```

## 🔧 Mocks e Setup

### **Mocks Globais (jest.setup.js):**
- Next.js Router mockado
- Prisma Client mockado
- Fetch API mockado
- Toast notifications mockado
- Socket.io mockado

### **Mocks Específicos:**
```typescript
// Mock de função
const mockFunction = jest.fn().mockReturnValue(result)

// Mock de módulo
jest.mock('module-name', () => ({
  functionName: jest.fn()
}))

// Mock de API
global.fetch = jest.fn(() =>
  Promise.resolve({
    ok: true,
    json: () => Promise.resolve(data)
  })
)
```

## ✅ Assertions Padrão

### **Validação de Sucesso:**
```typescript
expect(result.success).toBe(true)
expect(data).toBeDefined()
expect(array).toHaveLength(expectedLength)
```

### **Validação de Erro:**
```typescript
expect(result.success).toBe(false)
expect(result.error).toBeDefined()
expect(error.message).toContain('expected message')
```

### **Validação de Chamadas:**
```typescript
expect(mockFunction).toHaveBeenCalledWith(expectedArgs)
expect(mockFunction).toHaveBeenCalledTimes(expectedCalls)
```

### **Validação de Estado:**
```typescript
expect(screen.getByText('Loading')).toBeInTheDocument()
expect(element).toHaveClass('expected-class')
```

## 🚨 Troubleshooting

### **Problemas Comuns:**

#### **1. Warning de act():**
```typescript
import { act } from '@testing-library/react'

await act(async () => {
  // código que atualiza estado
})
```

#### **2. Erro de Timezone:**
```typescript
// Usar datas ISO com timezone
const date = new Date('2024-01-01T00:00:00.000Z')
```

#### **3. Console.error nos testes:**
```typescript
beforeEach(() => {
  jest.spyOn(console, 'error').mockImplementation(() => {})
})

afterEach(() => {
  jest.restoreAllMocks()
})
```

## 📊 Cobertura Atual

### **Implementado:**
- ✅ Schemas (100%)
- ✅ Hooks (90%)
- ✅ Components (80%)
- ✅ Utils (100%)
- ✅ Integration (85%)

### **Pendente:**
- ⏳ Services (problemas de mock do Prisma)
- ⏳ APIs (problemas de resolução de módulos)
- ⏳ Webhooks
- ⏳ E2E tests

## 🎯 Comandos Úteis

```bash
npm test                    # Executar todos os testes
npm run test:watch         # Executar com watch
npm test -- --coverage     # Verificar cobertura
npm test -- path/to/test   # Executar teste específico
```

## 📚 Documentação

- [Estratégia de Testes](mdc:docs/testing-strategy.md) - Documentação completa
- [Arquitetura](mdc:docs/architecture.md) - Visão geral do projeto
- [Melhores Práticas](mdc:docs/best-practices.md) - Padrões gerais
description:
globs:
alwaysApply: false
---
