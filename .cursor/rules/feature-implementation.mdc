# üöÄ Diretrizes de Implementa√ß√£o de Features

## üìã Checklist Obrigat√≥rio para Novas Features

### **1. An√°lise e Planejamento:**
- [ ] Identificar o dom√≠nio da feature (leads, conversations, dashboard, etc.)
- [ ] Definir schemas Zod necess√°rios
- [ ] Definir tipos TypeScript necess√°rios
- [ ] Planejar m√©todos do service
- [ ] Planejar hooks customizados
- [ ] Definir APIs necess√°rias

### **2. Implementa√ß√£o por Camadas:**

#### **Camada 1: Schemas e Tipos**
```typescript
// 1. Criar schema Zod
// src/schemas/[domain]/entity.ts
export const entitySchema = z.object({
  id: z.string(),
  name: z.string().min(1),
  // ... outros campos
})

// 2. Criar tipos TypeScript
// src/types/[domain]/entity.ts
export interface Entity {
  id: string
  name: string
  // ... outros campos
}

// 3. Adicionar exports
// src/schemas/[domain]/index.ts
export * from './entity'

// src/types/[domain]/index.ts
export * from './entity'
```

#### **Camada 2: Service (L√≥gica de Neg√≥cio)**
```typescript
// src/services/[domain]/entity-service.ts
export class EntityService {
  async getAll(): Promise<Entity[]> {
    return await prisma.entity.findMany({
      orderBy: { createdAt: 'desc' }
    })
  }

  async getById(id: string): Promise<Entity | null> {
    return await prisma.entity.findUnique({
      where: { id }
    })
  }

  async create(data: CreateEntityData): Promise<Entity> {
    return await prisma.entity.create({ data })
  }

  async update(id: string, data: UpdateEntityData): Promise<Entity> {
    return await prisma.entity.update({
      where: { id },
      data
    })
  }

  async delete(id: string): Promise<void> {
    await prisma.entity.delete({ where: { id } })
  }
}
```

#### **Camada 3: Hooks Customizados**
```typescript
// src/hooks/[domain]/use-entities.ts
export function useEntities() {
  const [entities, setEntities] = useState<Entity[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const fetchEntities = useCallback(async () => {
    try {
      setLoading(true)
      const service = new EntityService()
      const data = await service.getAll()
      setEntities(data)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Erro ao carregar dados')
    } finally {
      setLoading(false)
    }
  }, [])

  const createEntity = useCallback(async (data: CreateEntityData) => {
    try {
      const service = new EntityService()
      await service.create(data)
      await fetchEntities() // Recarregar dados
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Erro ao criar')
    }
  }, [fetchEntities])

  useEffect(() => {
    fetchEntities()
  }, [fetchEntities])

  return {
    entities,
    loading,
    error,
    refetch: fetchEntities,
    createEntity
  }
}
```

#### **Camada 4: APIs (Camada de Apresenta√ß√£o)**
```typescript
// src/app/api/[domain]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { EntityService } from '@/services/[domain]'
import { createEntitySchema } from '@/schemas/[domain]'

export async function GET() {
  try {
    const service = new EntityService()
    const entities = await service.getAll()
    return NextResponse.json(entities)
  } catch (error) {
    console.error('Erro ao buscar entidades:', error)
    return NextResponse.json(
      { message: 'Erro interno do servidor' },
      { status: 500 }
    )
  }
}

export async function POST(req: NextRequest) {
  try {
    const data = await req.json()
    const validatedData = createEntitySchema.parse(data)
    
    const service = new EntityService()
    const entity = await service.create(validatedData)
    
    return NextResponse.json(entity, { status: 201 })
  } catch (error) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { message: 'Dados inv√°lidos', errors: error.errors },
        { status: 400 }
      )
    }
    
    console.error('Erro ao criar entidade:', error)
    return NextResponse.json(
      { message: 'Erro interno do servidor' },
      { status: 500 }
    )
  }
}
```

#### **Camada 5: Componentes (UI)**
```typescript
// src/app/dashboard/[domain]/page.tsx
import { useEntities } from '@/hooks/[domain]'
import { ENTITY_OPTIONS } from '@/lib/utils/constants'
import { formatEntity } from '@/lib/utils/formatting'

export default function EntityPage() {
  const { entities, loading, error, createEntity } = useEntities()
  
  if (loading) return <div>Carregando...</div>
  if (error) return <div>Erro: {error}</div>
  
  return (
    <div>
      {entities.map(entity => (
        <div key={entity.id}>
          {formatEntity(entity)}
        </div>
      ))}
    </div>
  )
}
```

### **3. Utilit√°rios (Se Necess√°rio):**
```typescript
// src/lib/utils/constants.ts
export const ENTITY_OPTIONS = [
  { value: 'option1', label: 'Op√ß√£o 1' },
  { value: 'option2', label: 'Op√ß√£o 2' }
]

// src/lib/utils/formatting.ts
export const formatEntity = (entity: Entity) => {
  return `${entity.name} - ${entity.id}`
}
```

## üö® Regras Cr√≠ticas de Implementa√ß√£o

### **NUNCA FAZER:**
- ‚ùå Implementar l√≥gica de banco diretamente em componentes
- ‚ùå Duplicar c√≥digo existente
- ‚ùå Criar APIs fora de `src/app/api/`
- ‚ùå Usar `any` sem justificativa
- ‚ùå Misturar responsabilidades entre camadas

### **SEMPRE FAZER:**
- ‚úÖ Seguir a ordem de implementa√ß√£o (Schemas ‚Üí Types ‚Üí Service ‚Üí Hooks ‚Üí APIs ‚Üí Components)
- ‚úÖ Usar service layer para todas as opera√ß√µes de banco
- ‚úÖ Implementar valida√ß√£o com Zod em todas as APIs
- ‚úÖ Tratar erros adequadamente em todas as camadas
- ‚úÖ Usar hooks customizados para estado e l√≥gica
- ‚úÖ Centralizar constantes e utilit√°rios
- ‚úÖ Testar cada camada antes de prosseguir

## üîÑ Fluxo de Desenvolvimento

### **1. Desenvolvimento Iterativo:**
1. Implementar schemas e tipos
2. Implementar service com m√©todos b√°sicos
3. Implementar hooks para opera√ß√µes b√°sicas
4. Implementar APIs b√°sicas
5. Implementar UI b√°sica
6. Adicionar funcionalidades avan√ßadas
7. Refatorar e otimizar

### **2. Testes por Camada:**
- **Schemas:** Validar com dados de teste
- **Service:** Testar m√©todos individualmente
- **Hooks:** Testar estados e opera√ß√µes
- **APIs:** Testar endpoints com Postman/Thunder Client
- **Components:** Testar renderiza√ß√£o e intera√ß√µes

### **3. Valida√ß√£o Final:**
- [ ] `npm run lint` - Sem erros
- [ ] `npm run build` - Build bem-sucedido
- [ ] Testes funcionais b√°sicos
- [ ] Verificar se n√£o quebrou funcionalidades existentes

## üìö Exemplos de Implementa√ß√£o

### **Feature Simples (CRUD B√°sico):**
- Schemas: 1 arquivo
- Types: 1 arquivo
- Service: 1 classe com 5 m√©todos
- Hooks: 1 hook com opera√ß√µes b√°sicas
- APIs: 1 arquivo com GET/POST/PUT/DELETE
- Components: 1 p√°gina com lista e formul√°rio

### **Feature Complexa (Com Relacionamentos):**
- Schemas: 2-3 arquivos
- Types: 2-3 arquivos
- Service: 1 classe com m√©todos espec√≠ficos
- Hooks: 2-3 hooks especializados
- APIs: 2-3 arquivos de API
- Components: 2-3 p√°ginas/componentes

## üéØ Benef√≠cios da Abordagem

### **1. Manutenibilidade:**
- C√≥digo organizado por responsabilidade
- F√°cil localiza√ß√£o de problemas
- Mudan√ßas isoladas por camada

### **2. Reutiliza√ß√£o:**
- Services reutiliz√°veis entre APIs
- Hooks compartilhados entre componentes
- Utilit√°rios centralizados

### **3. Testabilidade:**
- Cada camada test√°vel independentemente
- Mocks f√°ceis de implementar
- Testes unit√°rios e de integra√ß√£o

### **4. Escalabilidade:**
- Estrutura preparada para crescimento
- Padr√µes consistentes
- F√°cil adi√ß√£o de novas funcionalidades

## üìö Documenta√ß√£o Relacionada

- [Arquitetura](mdc:docs/architecture.md) - Documenta√ß√£o completa da arquitetura
- [Melhores Pr√°ticas](mdc:docs/best-practices.md) - Padr√µes gerais do projeto
- [Guia de Erros](mdc:docs/lint-build-errors-guide.md) - Erros comuns e solu√ß√µes
description:
globs:
alwaysApply: false
---
