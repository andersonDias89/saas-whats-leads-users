# üöÄ Diretrizes de Implementa√ß√£o de Features

## üìã Checklist Obrigat√≥rio para Novas Features

### **1. An√°lise e Planejamento:**
- [ ] Identificar o dom√≠nio da feature (leads, conversations, dashboard, etc.)
- [ ] Definir schemas Zod necess√°rios
- [ ] Definir tipos TypeScript necess√°rios
- [ ] Planejar m√©todos do service
- [ ] Planejar hooks customizados
- [ ] Definir APIs necess√°rias

### **2. Implementa√ß√£o por Camadas:**

#### **Camada 1: Schemas e Tipos**
```typescript
// 1. Criar schema Zod
// src/schemas/[domain]/entity.ts
export const entitySchema = z.object({
  id: z.string(),
  name: z.string().min(1),
  // ... outros campos
})

// 2. Criar tipos TypeScript
// src/types/[domain]/entity.ts
export interface Entity {
  id: string
  name: string
  // ... outros campos
}

// 3. Adicionar exports
// src/schemas/[domain]/index.ts
export * from './entity'

// src/types/[domain]/index.ts
export * from './entity'
```

#### **Camada 2: Service (L√≥gica de Neg√≥cio)**
```typescript
// src/services/[domain]/entity-service.ts
export class EntityService {
  async getAll(): Promise<Entity[]> {
    return await prisma.entity.findMany({
      orderBy: { createdAt: 'desc' }
    })
  }

  async getById(id: string): Promise<Entity | null> {
    return await prisma.entity.findUnique({
      where: { id }
    })
  }

  async create(data: CreateEntityData): Promise<Entity> {
    return await prisma.entity.create({ data })
  }

  async update(id: string, data: UpdateEntityData): Promise<Entity> {
    return await prisma.entity.update({
      where: { id },
      data
    })
  }

  async delete(id: string): Promise<void> {
    await prisma.entity.delete({ where: { id } })
  }
}
```

#### **Camada 3: Hooks Customizados**
```typescript
// src/hooks/[domain]/use-entities.ts
export function useEntities() {
  const [entities, setEntities] = useState<Entity[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  const fetchEntities = useCallback(async () => {
    try {
      setLoading(true)
      const service = new EntityService()
      const data = await service.getAll()
      setEntities(data)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Erro ao carregar dados')
    } finally {
      setLoading(false)
    }
  }, [])

  const createEntity = useCallback(async (data: CreateEntityData) => {
    try {
      const service = new EntityService()
      await service.create(data)
      await fetchEntities() // Recarregar dados
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Erro ao criar entidade')
      throw err
    }
  }, [fetchEntities])

  useEffect(() => {
    fetchEntities()
  }, [fetchEntities])

  return {
    entities,
    loading,
    error,
    fetchEntities,
    createEntity
  }
}
```

#### **Camada 4: APIs REST**
```typescript
// src/app/api/[domain]/route.ts
import { NextRequest, NextResponse } from 'next/server'
import { getServerSession } from 'next-auth'
import { authOptions } from '@/lib/auth'
import { EntityService } from '@/services/[domain]'
import { createEntitySchema } from '@/schemas/[domain]'

export async function GET() {
  try {
    const session = await getServerSession(authOptions)
    
    if (!session?.user?.id) {
      return NextResponse.json(
        { message: 'N√£o autorizado' },
        { status: 401 }
      )
    }

    const entities = await EntityService.getAll()
    return NextResponse.json(entities)

  } catch (error) {
    console.error('Erro ao buscar entidades:', error)
    return NextResponse.json(
      { message: 'Erro interno do servidor' },
      { status: 500 }
    )
  }
}

export async function POST(request: NextRequest) {
  try {
    const session = await getServerSession(authOptions)
    
    if (!session?.user?.id) {
      return NextResponse.json(
        { message: 'N√£o autorizado' },
        { status: 401 }
      )
    }

    const body = await request.json()
    const validatedData = createEntitySchema.parse(body)
    
    const entity = await EntityService.create(validatedData)
    return NextResponse.json(entity, { status: 201 })

  } catch (error) {
    console.error('Erro ao criar entidade:', error)
    return NextResponse.json(
      { message: 'Erro interno do servidor' },
      { status: 500 }
    )
  }
}
```

#### **Camada 5: Componentes UI**
```typescript
// src/components/[domain]/create-entity-modal.tsx
'use client'

import { useState } from 'react'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { CreateEntityData, createEntitySchema } from '@/schemas/[domain]'

interface CreateEntityModalProps {
  open: boolean
  onOpenChange: (open: boolean) => void
  onSubmit: (data: CreateEntityData) => Promise<void>
}

export function CreateEntityModal({ open, onOpenChange, onSubmit }: CreateEntityModalProps) {
  const [isSubmitting, setIsSubmitting] = useState(false)
  
  const { register, handleSubmit, reset, formState: { errors } } = useForm<CreateEntityData>({
    resolver: zodResolver(createEntitySchema)
  })

  const handleFormSubmit = async (data: CreateEntityData) => {
    try {
      setIsSubmitting(true)
      await onSubmit(data)
      reset()
      onOpenChange(false)
    } catch (error) {
      // Erro j√° tratado no hook
    } finally {
      setIsSubmitting(false)
    }
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Criar Nova Entidade</DialogTitle>
        </DialogHeader>
        
        <form onSubmit={handleSubmit(handleFormSubmit)}>
          <Input {...register('name')} placeholder="Nome" />
          {errors.name?.message && (
            <p className="text-sm text-destructive">{errors.name.message}</p>
          )}
          
          <Button type="submit" disabled={isSubmitting}>
            {isSubmitting ? 'Criando...' : 'Criar'}
          </Button>
        </form>
      </DialogContent>
    </Dialog>
  )
}
```

## üéØ Padr√µes Espec√≠ficos por Dom√≠nio

### **Leads**
- **Schema**: `leadSchema` para valida√ß√£o geral, `createLeadSchema` para cria√ß√£o manual
- **Source**: Campo obrigat√≥rio com valores `'whatsapp'` | `'manual'`
- **Conversation**: Opcional (leads manuais n√£o t√™m conversa)
- **UI**: Modal de cria√ß√£o com √≠cones intuitivos (User, Phone, Mail, FileText)
- **Exibi√ß√£o**: Origem discreta ao lado do nome com √≠cones (MessageSquare vs Edit3)

### **Conversations**
- **Webhook**: Processamento de dados do Twilio
- **Messages**: Relacionamento 1:N com mensagens
- **Status**: Active, closed, archived

### **Dashboard**
- **Dados**: Agrega√ß√£o de leads, conversas e mensagens
- **Gr√°ficos**: Dados mensais dos √∫ltimos 6 meses
- **KPIs**: M√©tricas principais com compara√ß√£o m√™s anterior

## üö® Regras Importantes

### **Valida√ß√£o:**
- **Sempre usar Zod** para valida√ß√£o de dados
- **Schemas espec√≠ficos** para diferentes opera√ß√µes (cria√ß√£o vs atualiza√ß√£o)
- **Mensagens em portugu√™s** nos erros de valida√ß√£o

### **Autentica√ß√£o:**
- **Sempre verificar sess√£o** nas APIs
- **Usar getServerSession(authOptions)** para obter usu√°rio
- **Retornar 401** quando n√£o autenticado

### **Tratamento de Erros:**
- **Try/catch** em todas as opera√ß√µes ass√≠ncronas
- **Logs informativos** para debugging
- **Mensagens amig√°veis** para o usu√°rio
- **Status codes** apropriados

### **UI/UX:**
- **Loading states** para opera√ß√µes ass√≠ncronas
- **Feedback visual** de sucesso/erro
- **Valida√ß√£o em tempo real** nos formul√°rios
- **√çcones intuitivos** para melhor UX

### **Performance:**
- **useCallback** para fun√ß√µes em hooks
- **Depend√™ncias corretas** em useEffect
- **Lazy loading** para componentes pesados
- **Otimiza√ß√£o de re-renders**

## üìö Refer√™ncias

- [docs/architecture.md](mdc:docs/architecture.md) - Arquitetura detalhada
- [docs/testing-strategy.md](mdc:docs/testing-strategy.md) - Estrat√©gia de testes
- [docs/best-practices.md](mdc:docs/best-practices.md) - Melhores pr√°ticas
- [docs/lint-build-errors-guide.md](mdc:docs/lint-build-errors-guide.md) - Guia de erros

## üîÑ Fluxo de Desenvolvimento

1. **An√°lise**: Entender requisitos e definir estrutura
2. **Schemas**: Criar valida√ß√µes Zod
3. **Types**: Definir tipos TypeScript
4. **Service**: Implementar l√≥gica de neg√≥cio
5. **Hook**: Criar hook customizado
6. **API**: Implementar endpoints REST
7. **Component**: Criar componentes UI
8. **Test**: Escrever testes completos
9. **Document**: Atualizar documenta√ß√£o
10. **Review**: Revisar c√≥digo e qualidade
